{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isObject = isObject;\nexports.mergeDeep = mergeDeep;\nexports.equalsDeep = equalsDeep;\nexports.withoutKeys = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n/* eslint-disable no-restricted-syntax */\n\n\nvar withoutKeys = function withoutKeys(keys, propsObject) {\n  var result = Object.assign({}, propsObject);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n      delete result[key];\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return result;\n};\n/**\r\n * Simple object check.\r\n * @param item\r\n * @returns {boolean}\r\n */\n\n\nexports.withoutKeys = withoutKeys;\n\nfunction isObject(item) {\n  return item && _typeof(item) === 'object' && !Array.isArray(item);\n}\n/**\r\n * Deep merge two objects.\r\n * @param target\r\n * @param ...sources\r\n */\n\n\nfunction mergeDeep(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  if (!sources.length) return target;\n  var source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (var key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, _defineProperty({}, key, {}));\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, _defineProperty({}, key, source[key]));\n      }\n    }\n  }\n\n  return mergeDeep.apply(void 0, [target].concat(sources));\n}\n\nfunction equalsDeep(x, y) {\n  if (x === null || x === undefined || y === null || y === undefined) {\n    return x === y;\n  } // after this just checking type of one would be enough\n\n\n  if (x.constructor !== y.constructor) {\n    return false;\n  } // if they are functions, they should exactly refer to same one (because of closures)\n\n\n  if (x instanceof Function) {\n    return x === y;\n  } // if they are regexps, they should exactly refer to same one (it is hard to better equality check on current ES)\n\n\n  if (x instanceof RegExp) {\n    return x === y;\n  }\n\n  if (x === y || x.valueOf() === y.valueOf()) {\n    return true;\n  }\n\n  if (Array.isArray(x) && x.length !== y.length) {\n    return false;\n  } // if they are dates, they must had equal valueOf\n\n\n  if (x instanceof Date) {\n    return false;\n  } // if they are strictly equal, they both need to be object at least\n\n\n  if (!(x instanceof Object)) {\n    return false;\n  }\n\n  if (!(y instanceof Object)) {\n    return false;\n  } // recursive object equality check\n\n\n  var p = Object.keys(x);\n  return Object.keys(y).every(function (i) {\n    return p.indexOf(i) !== -1;\n  }) && p.every(function (i) {\n    return equalsDeep(x[i], y[i]);\n  });\n}\n/* eslint-enable no-restricted-syntax */","map":null,"metadata":{},"sourceType":"script"}